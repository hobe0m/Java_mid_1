package exception.ex4;

public class PracticalExceptionHandling {
    // 실무에서의 예외 처리 방법
    //  - 다수의 개발자들이 경험한 결과로써 무조건적인 정답은 아니지만 실무에서 통용되는 예외 처리 방법

    // 처리할 수 없는 예외
    // 예를 들어, 상대 네트워크 서버에 문제가 발생해서 통신이 불가능하거나, 데이터베이스 서버에 문제가 발생해서 접속이 안되면 애플리케이션에서 연결 오류, 데이터베이스 접속 실패와 같은 예외가 발생한다.
    // 이렇게 시스템 오류 때문에 발생한 예외들은 대부분 예외를 잡아도 해결할 수 있는 것이 거의 없다.
    //  - 예외를 잡아서 다시 호출을 시도해도 같은 오류가 반복될 뿐이다.
    // 이런 경우 고객에게는 "현재 시스템에 문제가 있습니다."라는 오류 메세지를 보여주고, 만약 웹이라면 오류 페이지를 보여주면 된다.
    // 그리고 내부 개발자가 문제 상황을 빠르게 인지할 수 있도록, 오류에 대한 로그를 남겨두어야 한다.

    // 체크 예외의 부담
    // 체크 예외는 개발자가 실수로 놓칠 수 있는 예외들을 컴파일러가 체크해주기 때문에 오래전부터 많이 사용되었다.
    // 그런데 앞서 설명한 것처럼 처리할 수 없는 예외가 많아지고, 또 프로그램이 점점 복잡해지면서 체크 예외를 사용하는 것이 점점 더 부담스러워졌다.

    // 체크 예외는 catch를 해서 복구를 할 수 있게끔 컴파일러가 잡아준다.
    // 체크 예외에 대한 부담과 처리할 수 없는 예외가 맞물리는 상황에 처하게 된다.

    // 체크 예외 사용 시나리오
    // 체크 예외를 사용하게 되면 어떤 문제가 발생하는지 알아보자.

    // 실무에서는 수 많은 라이브러리를 사용하고, 또 다양한 외부 시스템과 연동한다.
    // 사용하는 각각의 클래스들이 자신만의 예외를 모두 체크 예외로 만들어서 전달한다고 가정하자.
    // 결국에는 호출하는 곳에서 던져지는 체크 예외들을 모두 처리해야 하고, 처리하지 못하면 밖으로 던져야 한다.
    //  - 앞서 설명했듯이 상대 네트워크 서버가 내려갔거나, 데이터베이스 서버에 문제가 발생한 경우 복구할 수 없다.
    //  - 이렇게 되면 본인이 처리할 수 없는 예외들이기 때문에 밖으로 던지는 것이 더 나은 결정이다.
    //  - 그러면 던지는 예외들을 throws 옆에 모두 다 나열해야 한다.
    //  - 라이브러리가 늘어날수록 다루어야 하는 예외가 더 많아지기 때문에 개발자 입장에서는 번거로운 일이 된다.
    //  - 만약 중간에 호출하는 클래스가 하나 더 있을 때는 더 지저분한 코드가 만들어진다.
    //  - 어차피 처리하지 못하는 예외들을 다 잡아서 던지기만 하기 때문이다.
    //  - 체크 예외 지옥에 빠지게 되면 throws Exception과 같은 최악의 수를 두게 된다.

    // throws Exception이 가진 치명적인 약점
    //  - Exception은 최상위 타입이므로 모든 체크 예외를 다 밖으로 던지는 문제가 발생한다.
    //  - 결과적으로 다른 체크 예외를 체크할 수 있는 기능이 무효화 되고, 중요한 체크 예외를 다 놓치게 된다.
    //  - 중간에 중요한 체크 예외가 발생해도 컴파일러는 Exception을 던지기 때문에 문법에 맞다고 판단해서 컴파일 오류가 발생하지 않는다.
    //  - 따라서 이런식으로 하면 모든 예외를 다 던지기 때문에 체크 예외를 의도한 대로 사용하는 것이 아니다.
    //  - 따라서 꼭 필요한 경우가 아니면 이렇게 Exception 자체를 밖으로 던지는 것은 좋지 않은 방법이다.

    // 문제 정리
    // 지금까지 알아본 체크 예외를 사용할 때 발생하는 문제들은 다음과 같다.
    // 처리할 수 없는 예외 : 예외를 잡아서 복구할 수 있는 예외보다 복구할 수 없는 예외가 더 많다.
    // 체크 예외의 부담 : 처리할 수 없는 예외는 밖으로 던져야 하고, 체크 예외이므로 throws에 던질 대상을 일일해 명시해야 한다.

    // 실무에서 발생하는 예외의 경우 대다수가 내가 해결할 수 없는 예외이다.
    //  - 따라서 고객에게 먼저 알리고 내부 개발자를 위한 로그를 남긴다.
    //  - catch해서 해결할 수 있는 예외가 많이 없기 때문에 이러한 방식을 사용한다.

    // 서비스를 개발하는 개발자 입장에서는 수 많은 라이브러리에서 쏟아지는 예외, 특히 본인이 해결할 수 없는 모든 예외를 다 다루고 싶지는 않을 것이다.
    // 따라서 본인이 해결할 수 있는 예외만 잡아서 처리하고, 본인이 해결할 수 없는 예외는 신경쓰지 않는 것이 더 나은 선택일 수 있다.

    // 언체크 예외를 던지는 예시
    // 해결할 수 없는 언체크 예외가 발생하는 경우에는 잡아도 복구할 수 없으므로 그냥 무시하면 된다.
    // 언체크 예외이므로 throws를 선언하지 않아도 되고, 사용하는 라이브러리가 늘어나서 언체크 예외가 늘어도 본인이 필요한 예외만 잡으면 되고, throws를 늘리지 않아도 된다.
    // 언체크 예외는 잡지 않으면 throws 선언이 없어도 자동으로 밖으로 던져지므로 해결할 수 없는 건 그냥 두고 해결할 수 있는 예외만 잡아서 처리하면 된다.

    // 중요
    // 이 때, 잡아서 던지는 것이 던져서 그냥 두는 것이 아니라 예외 공통 처리를 통해 처리하는 것이다.
    
    // 예외 공통 처리
    // 해결할 수 없는 것은 아까 말했듯 고객에게 먼저 알리고, 개발자를 위한 로그를 남기면 된다.
    // 그리고 이러한 예외들은 여러 곳에서 나누어 처리하기 보다는 한 곳에 모아서 처리하는 것이 좋다.
    // 즉, 공통으로 처리하는 것이 효과적이다.
    //  - 고객에게 에러 메세지, 에러 발생 웹페이지 보여주고 개발자에게는 로그를 남김
    //  - 제일 끝단에서 처리
}
