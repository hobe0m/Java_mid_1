package nested.inner;

public class InnerOuterMain {
    public static void main(String[] args) {
        InnerOuter outer = new InnerOuter();

        // 바깥 클래스의 내부에 소속되어 있는 것이므로 바깥 클래스.new 내부 클래스()로 생성해야 한다.
        // 어느 인스턴스에 속해 있는지 확인하기 위해 이렇게 사용한다.
        // 여기서 outer는 InnerOuter 클래스의 인스턴스 참조값이다.
        // 내부 클래스에서는 바깥 클래스의 인스턴스 변수에도 접근 가능하기에, 참조값을 알아야 한다.
        //  - 따라서 아래와 같은 문법이 적용되는 것이다.
        //  - 내가 속해있는 외부 클래스의 인스턴스에서 새로운 내부 클래스 인스턴스를 생성하는 것이기 때문이다.
        InnerOuter.Inner inner = outer.new Inner();
        inner.print();

        // 클래스 정보 확인, 중첩된 클래스는 외부 클래스$내부 클래스로 표현된다.
        System.out.println("innerClass : " + inner.getClass());
    }

    // 내부 클래스는 바깥 클래스의 인스턴스에 소속되므로 바깥 클래스의 인스턴스 정보를 알아야 생성할 수 있다.
    //  - 따라서 내부 클래스는 new 바깥 클래스의 인스턴스 참조.내부 클래스()로 생성할 수 있다.
    //  - 내부 클래스는 바깥 클래스의 인스턴스에 속해 있어야 하기에 바깥 클래스의 인스턴스 참조가 필요한 것이다.
    //  - outer.new Inner()에서 outer가 바깥 클래스의 인스턴스 참조이다.
    // outer.new Inner()로 생성한 내부 클래스는 개념 상 바깥 클래스의 인스턴스 내부에 생성된다.
    // 따라서 바깥 클래스의 인스턴스를 먼저 생성해야 내부 클래스의 인스턴스를 생성할 수 있다.

    // 실제로는 내부 인스턴스가 바깥 인스턴스 안에 생성되는 것은 아니다.
    // 하지만 개념 상 인스턴스 안에 생성된다고 이해하면 충분하다.
    // 내부 인스턴스가 바깥 인스턴스의 참조를 보관해 이 참조를 통해 내부 인스턴스에 접근한다.

    // 정리
    // 정적 중첩 클래스와는 다르게 내부 클래스는 바깥 인스턴스에 소속된다.
    // 중첩이라는 단어와 내부라는 단어의 차이는 다음과 같다.
    //  - 중첩(Nested) : 어떤 다른 것이 내부에 위치하거나 포함되는 구조적인 단계
    //  - 내부(Inner) : 나의 내부에 있는 나를 구성하는 요소
    // 따라서 중첩은 나의 안에 있지만 내 것은 아닌 것, 내부는 나를 구성하는 내부의 어떤 것이라고 생각하면 된다.

    // 정적 중첩 클래스는 다른 클래스를 단순히 중첩, 내부 클래스는 바깥의 클래스의 인스턴스 내부에서 구성 요소로 사용되는 것이다.

}
